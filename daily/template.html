
<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Daily Dev Tips</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif; line-height: 1.7; margin: 2rem auto; max-width: 900px; padding: 0 1rem; }
    h1, h2 { line-height: 1.3; }
    details { border: 1px solid #ddd; border-radius: 10px; padding: 0.7rem 0.9rem; margin: 0.8rem 0; background: #fafafa; }
    summary { font-weight: 700; cursor: pointer; }
    .date { color: #555; margin-bottom: 1rem; }
    .toc li { margin: 0.25rem 0; }
    .section { margin-top: 1.2rem; }
  </style>
</head>
<body>
  <h1>Daily Dev Tips</h1>
  <p class="date">2026-02-24 (UTC)</p>

  <h2>目次</h2>
  <ul class="toc">
    <li><a href="#laravel">Laravel</a></li>
    <li><a href="#vue">Vue</a></li>
    <li><a href="#docker">Docker</a></li>
    <li><a href="#aws">AWS</a></li>
    <li><a href="#react">React</a></li>
    <li><a href="#typescript">TypeScript</a></li>
    <li><a href="#php-functions">PHP関数</a></li>
    <li><a href="#array-helpers">配列ヘルパー</a></li>
    <li><a href="#dash">Dash</a></li>
    <li><a href="#zapier">Zapier</a></li>
    <li><a href="#openclaw">OpenClaw</a></li>
  </ul>

  <div class="section">
    <details id="laravel">
      <summary>Laravel</summary>
      <p>FormRequest の <code>prepareForValidation()</code> で入力を先に正規化すると、バリデーションと後続ロジックが安定します。<br>
      Controller 内での if 分岐が減り、テストもしやすくなります。</p>
      <p><strong>なぜ面白い？</strong> 「入力の揺れ」を入口で吸収するだけで、実装全体の複雑さを一段下げられるから。</p>
      <p><strong>今日の実践ミニ課題（You）:</strong> 既存API 1本で FormRequest を導入し、日付・空文字・trim の正規化を追加して差分を確認。</p>
      <p>Links: <a href="https://laravel.com/docs/11.x/validation#preparing-input-for-validation">Laravel Validation</a> / <a href="https://laravel.com/docs/11.x/requests">Laravel Requests</a></p>
    </details>

    <details id="vue">
      <summary>Vue</summary>
      <p><code>watchEffect</code> と <code>watch</code> を使い分けると副作用の意図が明確になります。<br>
      「依存自動追跡（watchEffect）」と「対象を明示（watch）」を分けるのがコツです。</p>
      <p><strong>なぜ面白い？</strong> リアクティブ設計の“見えない依存”を可視化でき、バグの温床を減らせるから。</p>
      <p><strong>今日の実践ミニ課題（You）:</strong> 既存コンポーネント1つで watchEffect を watch に置換し、依存を明示化して挙動比較。</p>
      <p>Links: <a href="https://vuejs.org/guide/essentials/watchers.html">Vue Watchers</a></p>
    </details>

    <details id="docker">
      <summary>Docker</summary>
      <p>マルチステージビルドで「ビルド環境」と「実行環境」を分離すると、イメージが軽く安全になります。<br>
      依存キャッシュの層を意識すると CI 時間も短縮できます。</p>
      <p><strong>なぜ面白い？</strong> 速さ・小ささ・セキュリティを同時に改善できる、費用対効果の高い技術だから。</p>
      <p><strong>今日の実践ミニ課題（You）:</strong> 1サービスをマルチステージ化し、変更前後でイメージサイズと build 時間を比較。</p>
      <p>Links: <a href="https://docs.docker.com/build/building/multi-stage/">Docker Multi-stage</a></p>
    </details>

    <details id="aws">
      <summary>AWS</summary>
      <p>CloudWatch ではメトリクス単体より、Alarm と通知ルート（SNS/ChatOps）までセットで設計すると運用が回ります。<br>
      まずは「5xx」「レイテンシ」「DLQ滞留」など失敗系を優先監視。</p>
      <p><strong>なぜ面白い？</strong> 障害の“検知→連絡→初動”を自動化でき、復旧スピードが大きく変わるから。</p>
      <p><strong>今日の実践ミニ課題（You）:</strong> 既存1システムで最重要アラームを1つ作成し、テスト通知まで通す。</p>
      <p>Links: <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html">CloudWatch Alarms</a></p>
    </details>

    <details id="react">
      <summary>React</summary>
      <p>派生データを <code>useEffect</code> で state 化せず、描画中に計算する設計へ寄せるとバグが減ります。<br>
      Effect は外部同期（API・DOM・購読）に限定するのが基本です。</p>
      <p><strong>なぜ面白い？</strong> state の重複を消すだけで再レンダリング設計がシンプルになり、保守性が上がるから。</p>
      <p><strong>今日の実践ミニ課題（You）:</strong> 1コンポーネントで「Effectで作る派生state」を削除し、計算プロパティ化する。</p>
      <p>Links: <a href="https://react.dev/learn/you-might-not-need-an-effect">You Might Not Need an Effect</a></p>
    </details>

    <details id="typescript">
      <summary>TypeScript</summary>
      <p>判別可能ユニオン（discriminated union）を使うと、条件分岐で型安全な状態管理ができます。<br>
      <code>switch</code> + exhaustive check を入れると未対応ケースをコンパイル時に検知できます。</p>
      <p><strong>なぜ面白い？</strong> 仕様変更時に「漏れ」を型が教えてくれるので、実装の安心感が段違いだから。</p>
      <p><strong>今日の実践ミニ課題（You）:</strong> APIレスポンス型を union 化し、<code>never</code> を使った網羅チェックを1箇所追加。</p>
      <p>Links: <a href="https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html">TS Unions</a> / <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html">TS Narrowing</a></p>
    </details>

    <details id="php-functions">
      <summary>PHP関数</summary>
      <p><code>array_reduce</code> は集計ロジックを1パスにまとめられる反面、可読性が下がることがあります。<br>
      キー付き連想配列の集約では <code>foreach</code> のほうが明快な場面も多いです。</p>
      <p><strong>なぜ面白い？</strong> “関数型っぽさ”と“チーム可読性”のバランス感覚を鍛えられるから。</p>
      <p><strong>今日の実践ミニ課題（You）:</strong> 同じ集計を reduce / foreach の2実装で書き、可読性と実行時間を比較。</p>
      <p>Links: <a href="https://www.php.net/manual/ja/function.array-reduce.php">array_reduce</a></p>
    </details>

    <details id="array-helpers">
      <summary>配列ヘルパー</summary>
      <p>Laravel の <code>data_get()</code> は配列・オブジェクト混在データの深い参照を統一できます。<br>
      ワイルドカード指定で複数要素を一気に抜き出せるのも便利です。</p>
      <p><strong>なぜ面白い？</strong> ネストの深いデータ処理で null チェック地獄から抜けやすくなるから。</p>
      <p><strong>今日の実践ミニ課題（You）:</strong> APIレスポンス整形処理を data_get ベースに置換し、例外パターンを1つ追加テスト。</p>
      <p>Links: <a href="https://laravel.com/docs/11.x/helpers#method-data-get">data_get Helper</a></p>
    </details>

    <details id="dash">
      <summary>Dash</summary>
      <p>Dash では callback の Input/State の切り分けがパフォーマンスに直結します。<br>
      頻繁に変わる値は Input、トリガー不要の補助値は State に寄せるのが基本です。</p>
      <p><strong>なぜ面白い？</strong> 同じUIでも callback 設計だけで体感速度が目に見えて変わるから。</p>
      <p><strong>今日の実践ミニ課題（You）:</strong> 既存 callback 1本で Input を見直し、不要な再実行回数を計測して記録。</p>
      <p>Links: <a href="https://dash.plotly.com/basic-callbacks">Dash Basic Callbacks</a></p>
    </details>

    <details id="zapier">
      <summary>Zapier</summary>
      <p>Zap の先頭に Filter / Paths を置くと、不要処理や誤通知を初期段階で止められます。<br>
      タスク消費を抑えつつ、運用時のノイズも減らせます。</p>
      <p><strong>なぜ面白い？</strong> 自動化は“作る”より“誤作動させない”設計が価値を生むから。</p>
      <p><strong>今日の実践ミニ課題（You）:</strong> よく使う Zap 1本に Filter を追加し、1週間分の無駄実行削減見込みを試算。</p>
      <p>Links: <a href="https://help.zapier.com/hc/en-us/articles/8496288690317-Use-filters-in-Zaps">Zapier Filters</a></p>
    </details>

    <details id="openclaw">
      <summary>OpenClaw</summary>
      <p>定期通知は Cron と Heartbeat を役割分担すると運用が安定します。<br>
      「時刻厳守」は Cron、「まとめて軽く確認」は Heartbeat が向いています。</p>
      <p><strong>なぜ面白い？</strong> 自動化の粒度を設計するだけで、通知疲れと見逃しの両方を減らせるから。</p>
      <p><strong>今日の実践ミニ課題（You）:</strong> 監視タスクを1つ選び、Cron/Heartbeatどちらが適切か判断理由をメモ化。</p>
      <p>Links: <a href="https://docs.openclaw.ai">OpenClaw Docs</a> / <a href="https://github.com/openclaw/openclaw">OpenClaw GitHub</a></p>
    </details>
  </div>

  <h2>今日の深掘り候補</h2>
  <p><strong>TypeScript の判別可能ユニオン + React reducer</strong><br>
  画面状態（idle/loading/success/error）を union で定義し、未対応分岐をコンパイルエラーにする設計を試してみよう。</p>
</body>
</html>
